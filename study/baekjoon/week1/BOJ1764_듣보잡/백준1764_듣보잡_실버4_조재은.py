'''
집합 자료형 set과 list의 특성을 잘 활용하면 되는문제이다.
문제의 key point는 아래와 같다.
 > 듣도 못한 사람의 명단에는 "중복되는 이름이 없으며", 보도 못한 사람의 명단도 마찬가지이다.

#################################################################################
#################################################################################
[집합 자료형의 특징]
 1. 중복을 허용하지 않는다.
 2. 순서가 없다
리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있지만, set 자료형은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없다.
이는 마치 딕셔너리와 비슷하다. 딕셔너리 역시 순서가 없는 자료형이라 인덱싱을 지원하지 않는다.

* 만약, set 자료향에 저장된 값을 인덱싱으로 접근하려면 다음과 같이 리스트나 튜플로 변환한 후 해야한다.
* 중복을 허용하지 않는 set의 특징은 자료형의 중복을 제거하기 위한 필터 역할로 종종 사용한다.

- 교집합 = s1 & s2
- 합집합 = s1 | s2
- 차집합 = s1 - s2 => differnce 함수 사용 가능
#################################################################################

a,b 이름을 각각 중복이 없는 set의 특성을 활용해서 입력받은 문자들을 add()해준다
 * list는 append()로 추가

set a, b에 교집합 &를 구해서 중복되는 문자열을 선택하고 list()로 묶어 리스트화 시킨 후 명단을 사전 순으로 제출해야 되니
sorted() 해준다.

듣보잡의 수를 알기 위해 len()를 사용하여 print하고 for문을 이용해서 result에 들어가 있는 문자열을 출력하면 된다.

'''

# 입력 갑 읽기
# 듣도 못한 사람의 수 n, 보도 못한 사람의 수 m
n, m = map(int, input().split())

a = set()
for i in range(n):
    a.add(input())

b = set()
for i in range(m):
    b.add(input())

result = sorted(list(a & b))

print(len(result))

for i in result:
    print(i) # print(변수, seq='\n') => for문 안돌리고 출력 가능